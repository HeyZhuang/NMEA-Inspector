# 个人软件实践说明书

## 学生信息
- **姓名**：[学生姓名]
- **学号**：[学号]
- **专业**：[专业]
- **班级**：[班级]

## 项目概述
**项目名称**：AI串口NMEA解析器 - GNSS数据可视化软件
**项目类型**：基于Qt的跨平台桌面应用程序
**开发语言**：C++
**开发框架**：Qt 5.15+ (Qt Charts)

## 个人负责模块

### 1. 图表渲染模块 (ChartManager)
**职责范围**：
- 负责三种核心图表的实现和渲染
- 实现数据的实时可视化更新
- 优化图表性能和用户体验

**技术实现**：
```cpp
class ChartManager : public QObject
{
    Q_OBJECT
public:
    QChartView* getSNRChartView() const;      // 信噪比柱状图
    QChartView* getRadarChartView() const;   // 卫星雷达图
    QChartView* getTrajectoryChartView() const; // 运动轨迹图
    
    void updateSNRChart(const QList<SatelliteInfo> &satellites);
    void updateRadarChart(const QList<SatelliteInfo> &satellites);
    void updateTrajectoryChart(const QList<GNSSData> &dataHistory);
};
```

### 2. 信噪比柱状图 (SNR Bar Chart)
**功能描述**：
- 按卫星ID显示信噪比强度
- 支持最多8个卫星的独立显示
- 自动调整Y轴范围

**技术实现**：
```cpp
void ChartManager::updateSNRChart(const QList<SatelliteInfo> &satellites)
{
    // 清空现有数据
    m_snrBarSet->remove(0, m_snrBarSet->count());
    
    // 添加新的卫星数据，最多8个
    QStringList categories;
    QList<double> snrValues;
    
    for (const SatelliteInfo &satellite : satellites) {
        if (satellite.snr > 0 && snrValues.size() < 8) {
            snrValues.append(satellite.snr);
            categories.append(QString::number(satellite.id));
        }
    }
    
    // 添加数据到柱状图
    for (double snr : snrValues) {
        *m_snrBarSet << snr;
    }
    
    // 自动调整Y轴范围
    if (!snrValues.isEmpty()) {
        double maxSNR = *std::max_element(snrValues.begin(), snrValues.end());
        QValueAxis *axisY = qobject_cast<QValueAxis*>(m_snrChart->axes(Qt::Vertical).first());
        if (axisY) {
            axisY->setRange(0, maxSNR + 5);
        }
    }
}
```

**技术特点**：
- **QBarSeries**：柱状图数据系列
- **QCategoryAxis**：分类轴标签管理
- **QValueAxis**：数值轴范围控制
- **动态更新**：实时数据刷新机制

### 3. 卫星雷达图 (Satellite Radar Map)
**功能描述**：
- 极坐标显示卫星空间分布
- 方位角(-180°到180°)和高度角(0°到90°)
- 支持不同卫星系统的颜色区分

**技术实现**：
```cpp
void ChartManager::updateRadarChart(const QList<SatelliteInfo> &satellites)
{
    // 清空现有数据
    m_radarSeries->clear();
    
    // 添加所有有效卫星数据
    for (const SatelliteInfo &satellite : satellites) {
        if (satellite.elevation >= 0 && satellite.azimuth >= 0) {
            m_radarSeries->append(satellite.azimuth, satellite.elevation);
        }
    }
    
    // 设置散点样式
    m_radarSeries->setMarkerSize(15);
    m_radarSeries->setColor(QColor(54, 162, 235));
    m_radarSeries->setBorderColor(QColor(255, 255, 255));
    m_radarSeries->setPen(QPen(QColor(54, 162, 235), 2));
}
```

**技术特点**：
- **QScatterSeries**：散点图数据系列
- **极坐标系统**：方位角和高度角的映射
- **视觉增强**：标记点大小和颜色设置
- **实时更新**：卫星状态的动态显示

### 4. 运动轨迹图 (Motion Trajectory Map)
**功能描述**：
- 显示GNSS设备的运动轨迹
- 支持小范围轨迹的清晰显示
- 自动调整坐标轴范围

**技术实现**：
```cpp
void ChartManager::updateTrajectoryChart(const QList<GNSSData> &dataHistory)
{
    // 清空现有数据
    m_trajectorySeries->clear();
    
    // 添加轨迹点
    double minLon = 180, maxLon = -180;
    double minLat = 90, maxLat = -90;
    bool hasValidData = false;
    
    for (const GNSSData &data : dataHistory) {
        if (data.latitude != 0.0 && data.longitude != 0.0) {
            m_trajectorySeries->append(data.longitude, data.latitude);
            hasValidData = true;
            
            // 计算边界
            minLon = qMin(minLon, data.longitude);
            maxLon = qMax(maxLon, data.longitude);
            minLat = qMin(minLat, data.latitude);
            maxLat = qMax(maxLat, data.latitude);
        }
    }
    
    // 自动调整坐标轴范围
    if (hasValidData && m_trajectorySeries->count() > 0) {
        double lonRange = maxLon - minLon;
        double latRange = maxLat - minLat;
        
        // 如果范围太小，设置最小范围
        if (lonRange < 0.0001) {
            lonRange = 0.0001; // 最小0.0001度范围
        }
        if (latRange < 0.0001) {
            latRange = 0.0001; // 最小0.0001度范围
        }
        
        // 添加一些边距
        double lonMargin = lonRange * 0.5; // 增加边距到50%
        double latMargin = latRange * 0.5;
        
        QValueAxis *axisX = qobject_cast<QValueAxis*>(m_trajectoryChart->axes(Qt::Horizontal).first());
        QValueAxis *axisY = qobject_cast<QValueAxis*>(m_trajectoryChart->axes(Qt::Vertical).first());
        
        if (axisX) {
            axisX->setRange(minLon - lonMargin, maxLon + lonMargin);
        }
        if (axisY) {
            axisY->setRange(minLat - latMargin, maxLat + latMargin);
        }
        
        // 设置轨迹线样式
        m_trajectorySeries->setPen(QPen(QColor(75, 192, 192), 3));
        m_trajectorySeries->setPointsVisible(true);
    }
}
```

**技术特点**：
- **QSplineSeries**：样条曲线数据系列
- **自适应缩放**：智能调整坐标轴范围
- **最小范围设置**：确保小轨迹的可见性
- **轨迹样式**：线条粗细和颜色设置

## 开发过程

### 阶段1：Qt Charts学习 (1周)
- 学习Qt Charts框架的基本概念
- 掌握QChart、QChartView等核心类
- 理解数据系列和坐标轴的关系

### 阶段2：图表原型开发 (2周)
- 实现三种图表的基本功能
- 设计数据更新机制
- 优化图表样式和布局

### 阶段3：性能优化 (1周)
- 实现数据筛选和限制
- 优化渲染性能
- 增强用户体验

## 技术收获

### 1. Qt Charts框架
- **QChart类**：图表容器和配置
- **QChartView类**：图表视图和交互
- **数据系列**：QBarSeries、QScatterSeries、QSplineSeries
- **坐标轴**：QValueAxis、QCategoryAxis

### 2. 数据可视化技术
- **实时更新**：数据的动态刷新机制
- **坐标系统**：极坐标和直角坐标的转换
- **视觉设计**：颜色、大小、样式的合理搭配
- **性能优化**：大数据量的处理策略

### 3. 用户体验设计
- **自适应布局**：图表大小的自动调整
- **交互反馈**：鼠标悬停和点击事件
- **视觉层次**：重要信息的突出显示
- **响应式设计**：不同屏幕尺寸的适配

## 遇到的问题与解决方案

### 问题1：信噪比图表显示密集
**现象**：所有卫星挤在一起，难以区分
**解决方案**：
- 限制显示数量（最多8个）
- 按信噪比排序，优先显示高质量卫星
- 优化X轴标签的显示方式

### 问题2：雷达图显示稀疏
**现象**：卫星点太小，分布不明显
**解决方案**：
- 增大标记点大小（15像素）
- 添加边框和线条样式
- 优化颜色对比度

### 问题3：轨迹图不显示
**现象**：小范围轨迹无法显示
**解决方案**：
- 设置最小显示范围（0.0001度）
- 增加边距到50%
- 强制显示轨迹点

### 问题4：图表更新不及时
**现象**：数据变化后图表没有刷新
**解决方案**：
- 添加强制刷新调用
- 优化数据更新时机
- 实现增量更新机制

## 项目贡献

### 代码贡献
- **ChartManager类**：约300行代码
- **图表更新方法**：约200行代码
- **样式配置**：约100行代码
- **总计**：约600行核心代码

### 测试数据贡献
- **test_data_full.nmea**：包含16个卫星的完整数据
- **test_data_enhanced.nmea**：包含6个时间点的轨迹数据
- **test_data_more_satellites.nmea**：包含12个卫星的数据

### 文档贡献
- 图表设计文档
- 数据可视化规范
- 性能优化指南
- 用户界面设计说明

## 学习总结

### 技术能力提升
1. **Qt Charts技能**：掌握了专业图表库的使用
2. **数据可视化**：学会了复杂数据的图形化展示
3. **用户体验设计**：具备了良好的界面设计能力
4. **性能优化**：掌握了大数据量处理的优化方法

### 工程能力提升
1. **模块化设计**：实现了清晰的图表管理架构
2. **接口设计**：为其他模块提供了标准化的接口
3. **测试驱动**：通过测试数据验证功能正确性
4. **文档编写**：能够编写详细的技术文档

### 团队协作
1. **接口对接**：与数据解析模块的完美集成
2. **代码规范**：遵循了统一的编码标准
3. **版本控制**：熟练使用Git进行协作开发
4. **技术交流**：与团队成员分享图表设计经验

## 答辩准备

### 技术演示
1. **图表渲染演示**：展示三种图表的实时更新
2. **数据可视化演示**：展示不同数据类型的图形化
3. **性能优化演示**：展示大数据量的处理能力

### 技术问答准备
1. **Qt Charts框架**：图表库的核心概念
2. **数据可视化原理**：图形化展示的技术基础
3. **性能优化策略**：大数据量处理的优化方法
4. **用户体验设计**：界面设计的考虑因素

### 代码展示
1. **核心算法**：图表更新的核心逻辑
2. **设计模式**：图表管理的架构设计
3. **性能优化**：渲染性能的优化技巧
4. **测试用例**：图表功能的测试方法

---

**备注**：本说明书详细记录了个人在数据可视化模块中的技术贡献，展现了专业的图表渲染能力和用户体验设计水平。
